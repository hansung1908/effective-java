# effective-java
'effective java 3/e - 조슈아 블로크'를 읽고 정리하는 글

## 객체 생성과 파괴
객체를 만들어야 할때와 만들지 말아야 할때를 구분하는 법, 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법, 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령을 알아본다.

  - ### 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라
    - 정적 팩터리 메서드가 생성자보다 좋은 이유 5가지
      >- 첫번째, 이름을 가질 수 있다.
      >- 두번째, 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
      >- 세번째, 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
      >- 네번째, 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
      >- 다섯 번째, 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

  - ### 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라
    - 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
    - 자바빈즈 패턴에서는 객체 하나를 만들려면 메서드를 여러개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.
    - 빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내 낸 것이다.
    - 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.

  - ### 아이템 3. private 생성자나 열거타입으로 싱글턴임을 보증하라
    - 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.
    - 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.

  - ### 아이템 4. 인스텀스화를 막으려거든 private 생성자를 사용하라
    - 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.
    - private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

  - ### 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
    - 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
    - 인스턴스를 생성할 때 필요한 자원을 넘겨주는 방식으로 의존 객체인 사전을 주입해주면 된다.
    - 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.

  - ### 아이템 6. 불필요한 객체 생성을 피하라
    - String.matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.
    - 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
    - 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.

  - ### 아이템 7. 다 쓴 객체 참조를 해제하라
    - 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
    - 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다.
    - 캐시 역시 메모리 누수를 일으키는 주범이다.

  - ### 아이템 8. finalizer와 cleaner 사용을 피하라
    - finalizer는 예측할 수 없고, 상황에따라 위험할 수 있어 일반적으로 불필요하다.
    - cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일번적으로 불필요하다.
    - 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.
    - finalizer와 cleaner는 심각한 성능 문제도 동반한다.
    - finalizer를 사용한 클래스는 finalizer 공격에 노출되엉 심각한 보안 문제를 일으킬 수도 있다.
    - 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, finalizer가 있다면 그렇지도 않다.
    - final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지않는 finalize 메서드를 만들고 final을 선언하자.
    - finalizer와 cleaner을 대신해줄 묘안으로 AutoCloseable을 구현해주고 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다.
    - 일반적으로 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용해야 햔다.

  - ### 아이템 9. try-finally보다는 try-with-resources를 사용하라
    - 꼭 회수해야 하는 자원을 다룰 때는 try-with-resources를 사용하자.
    - 예외는 없다. 코드는 더 짧고 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다.

## 모든 객체의 공통 메서드
Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 모두 재정의를 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확이 정의되어 있다.

  - ### 아이템 10. equals는 일반 규약을 지켜 재정의하라
    - 다음에서 열거한 상화중 하나에 해당한다면 재정의하지 않는 것이 최선이다.
      >- 각 인스턴스가 본질적으로 고유하다.
      >- 인스턴스의 '논리적 동치성 (logical equality)'을 검사할 일이 없다.
      >- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
      >- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 있다.
    
    - equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 한다.
      >- equals 메서드는 동치관계를 구현하며, 다음을 만족한다.
      >- 반사성 (reflexivity) : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true이다.
      >- 대칭성 (symmetry) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
      >- 추이성 (transitivity) : null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.euals(z)도 true면 x.equals(z)도 true다.
      >- 일관성 (consistency) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
      >- null-아님 (non-null) : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.
    
    - equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다.
    - 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
    - equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.
    
    - 양질의 equals 메서드 구현 방법을 단계별로 정리해보겠다.
      >1. == 연산자를 사용해 입력이 자기 자신이 참조인지 확인한다.
      >2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
      >3. 입력을 올바른 타입으로 형변환한다.
      >4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모드 일치하는지 하나씩 검사한다.
    
    - equals를 다 구현했다면 세 가지만 자문해보자. 대칭적인가? 추이성이 있는가? 일관적인가?
  
  - ### 아이템 11. equals를 재정의하려거든 hashCode도 재정의하라
    - equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.
    - 다음은 Object 명세에서 발췌한 규약이다.
      >- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
      >- equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
      >- equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환애야 해시테이블의 성능이 좋아진다.
    
    - hash 재정의를 잘못했을 때 크게 문제가 되는 조항은 두 번째다.
    - hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다.

  - ### 아이템 12. toString을 항상 재정의하라
    - toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
    - 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.
    - 포맷을 명시하든 아니든 여러분의 의도는 명확히 밝혀야 한다.
    - toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.

  - ### 아이템 13. clone 재정의는 주의해서 진행하라
    - 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.
    - clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.
    - Cloneable 아키텍처는 '가변 객체를 참조하는 필드는 final로 선언하라'는 일반 용법과 충돌한다.
    - public인 clone 메서드에서는 throw절을 없애야 한다.
    - Cloneable/clone 방식보다 복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있다.

  - ### 아이템 14. Comparable을 구현할지 고려하라
    - compareTo 메서드의 일반 규약은 equals의 규약과 비슷하다.
      >- 이 객체와 주어진 객체의 순서를 비교한다.
      >- 이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환한다.
      >- 이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.
      >- 다음 설명에서 sgn(표현식) 표기는 수학에서 말하는 부호 함수(signum function)를 뜻하며, 표현식의 값이 음수, 0, 양수일 때 -1, 0, 1을 반환하도록 정의했다.
      >---
      >- Comparable을 구현한 클래스는 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))여야 한다. (따라서 x.compareTo(y)는 y.compareTo(x)가 예외를 던질때에 한해 예외를 던져야 한다)
      >- Comparable을 구현한 클래스는 추이성을 보장해야 한다. 즉, (x.compareTo(y) > 0 && y.compareTo(z) > 0)이면 x.compareTo(z) > 0이다.
      >- Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))다.
      >- 이번 권고가 필수는 아니지만 꼭 지키는 게 좋다. (x.compareTo(y) == 0) == (x.equals(y))여야 한다.
      >- Comparable을 구현하고 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다. 다음과 같이 명시하면 적당할 것이다.
      >- "주의 : 이 클래스의 순서는 equals 메서드와 일관되지 않다."
    
    - 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다.
    - compareTo 메서드에서 관계 연산자 <와 >를 사용하는 이전 방식을 거추장스럽고 오류를 유발하니, 이제는 추천하지 않는다.
    - 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.