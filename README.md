# effective-java
'effective java 3/e - 조슈아 블로크'를 읽고 정리하는 글

## 객체 생성과 파괴
객체를 만들어야 할때와 만들지 말아야 할때를 구분하는 법, 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법, 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령을 알아본다.

  - ### 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라
    - 정적 팩터리 메서드가 생성자보다 좋은 이유 5가지
      >- 첫번째, 이름을 가질 수 있다.
      >- 두번째, 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
      >- 세번째, 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
      >- 네번째, 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
      >- 다섯 번째, 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

  - ### 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라
    - 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
    - 자바빈즈 패턴에서는 객체 하나를 만들려면 메서드를 여러개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.
    - 빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내 낸 것이다.
    - 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.

  - ### 아이템 3. private 생성자나 열거타입으로 싱글턴임을 보증하라
    - 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.
    - 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.

  - ### 아이템 4. 인스텀스화를 막으려거든 private 생성자를 사용하라
    - 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.
    - private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

  - ### 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
    - 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
    - 인스턴스를 생성할 때 필요한 자원을 넘겨주는 방식으로 의존 객체인 사전을 주입해주면 된다.
    - 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.

  - ### 아이템 6. 불필요한 객체 생성을 피하라
    - String.matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.
    - 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
    - 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.

  - ### 아이템 7. 다 쓴 객체 참조를 해제하라
    - 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
    - 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다.
    - 캐시 역시 메모리 누수를 일으키는 주범이다.

  - ### 아이템 8. finalizer와 cleaner 사용을 피하라
    - finalizer는 예측할 수 없고, 상황에따라 위험할 수 있어 일반적으로 불필요하다.
    - cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일번적으로 불필요하다.
    - 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.
    - finalizer와 cleaner는 심각한 성능 문제도 동반한다.
    - finalizer를 사용한 클래스는 finalizer 공격에 노출되엉 심각한 보안 문제를 일으킬 수도 있다.
    - 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, finalizer가 있다면 그렇지도 않다.
    - final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지않는 finalize 메서드를 만들고 final을 선언하자.
    - finalizer와 cleaner을 대신해줄 묘안으로 AutoCloseable을 구현해주고 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다.
    - 일반적으로 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용해야 햔다.

  - ### 아이템 9. try-finally보다는 try-with-resources를 사용하라
    - 꼭 회수해야 하는 자원을 다룰 때는 try-with-resources를 사용하자.
    - 예외는 없다. 코드는 더 짧고 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다.

## 모든 객체의 공통 메서드
Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 모두 재정의를 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확이 정의되어 있다.

  - ### equals는 일반 규약을 지켜 재정의하라
    - 다음에서 열거한 상화중 하나에 해당한다면 재정의하지 않는 것이 최선이다.
      >- 각 인스턴스가 본질적으로 고유하다.
      >- 인스턴스의 '논리적 동치성 (logical equality)'을 검사할 일이 없다.
      >- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
      >- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 있다.
    
    - equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 한다.
      >- equals 메서드는 동치관계를 구현하며, 다음을 만족한다.
      >- 반사성 (reflexivity) : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true이다.
      >- 대칭성 (symmetry) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
      >- 추이성 (transitivity) : null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.euals(z)도 true면 x.equals(z)도 true다.
      >- 일관성 (consistency) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
      >- null-아님 (non-null) : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.
    
    - equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다.
    - 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
    - equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.
    
    - 양질의 equals 메서드 구현 방법을 단계별로 정리해보겠다.
      >1. == 연산자를 사용해 입력이 자기 자신이 참조인지 확인한다.
      >2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
      >3. 입력을 올바른 타입으로 형변환한다.
      >4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모드 일치하는지 하나씩 검사한다.
    
    - equals를 다 구현했다면 세 가지만 자문해보자. 대칭적인가? 추이성이 있는가? 일관적인가?