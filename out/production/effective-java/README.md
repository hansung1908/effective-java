# effective-java
'effective java 3/e - 조슈아 블로크'를 읽고 정리하는 글

## 객체 생성과 파괴
객체를 만들어야 할때와 만들지 말아야 할때를 구분하는 법, 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법, 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령을 알아본다.

  - ### 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라
    - 정적 팩터리 메서드가 생성자보다 좋은 이유 5가지
      >- 첫번째, 이름을 가질 수 있다.
      >- 두번째, 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
      >- 세번째, 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
      >- 네번째, 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
      >- 다섯 번째, 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

  - ### 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라
    - 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
    - 자바빈즈 패턴에서는 객체 하나를 만들려면 메서드를 여러개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.
    - 빌더 패턴은 (파이썬과 스칼라에 있는) 명명된 선택적 매개변수를 흉내 낸 것이다.
    - 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기에 좋다.

  - ### 아이템 3. private 생성자나 열거타입으로 싱글턴임을 보증하라
    - 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.
    - 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.

  - ### 아이템 4. 인스텀스화를 막으려거든 private 생성자를 사용하라
    - 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.
    - private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.

  - ### 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
    - 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
    - 인스턴스를 생성할 때 필요한 자원을 넘겨주는 방식으로 의존 객체인 사전을 주입해주면 된다.
    - 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해준다.

  - ### 아이템 6. 불필요한 객체 생성을 피하라
    - String.matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.
    - 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
    - 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.

  - ### 아이템 7. 다 쓴 객체 참조를 해제하라
    - 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
    - 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다.
    - 캐시 역시 메모리 누수를 일으키는 주범이다.

  - ### 아이템 8. finalizer와 cleaner 사용을 피하라
    - finalizer는 예측할 수 없고, 상황에따라 위험할 수 있어 일반적으로 불필요하다.
    - cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일번적으로 불필요하다.
    - 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.
    - finalizer와 cleaner는 심각한 성능 문제도 동반한다.
    - finalizer를 사용한 클래스는 finalizer 공격에 노출되엉 심각한 보안 문제를 일으킬 수도 있다.
    - 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, finalizer가 있다면 그렇지도 않다.
    - final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지않는 finalize 메서드를 만들고 final을 선언하자.
    - finalizer와 cleaner을 대신해줄 묘안으로 AutoCloseable을 구현해주고 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다.
    - 일반적으로 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용해야 햔다.

  - ### 아이템 9. try-finally보다는 try-with-resources를 사용하라
    - 꼭 회수해야 하는 자원을 다룰 때는 try-with-resources를 사용하자.
    - 예외는 없다. 코드는 더 짧고 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다.

## 모든 객체의 공통 메서드
Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 모두 재정의를 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확이 정의되어 있다.

  - ### 아이템 10. equals는 일반 규약을 지켜 재정의하라
    - 다음에서 열거한 상화중 하나에 해당한다면 재정의하지 않는 것이 최선이다.
      >- 각 인스턴스가 본질적으로 고유하다.
      >- 인스턴스의 '논리적 동치성 (logical equality)'을 검사할 일이 없다.
      >- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
      >- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 있다.
    
    - equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 한다.
      >- equals 메서드는 동치관계를 구현하며, 다음을 만족한다.
      >- 반사성 (reflexivity) : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true이다.
      >- 대칭성 (symmetry) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다.
      >- 추이성 (transitivity) : null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.euals(z)도 true면 x.equals(z)도 true다.
      >- 일관성 (consistency) : null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
      >- null-아님 (non-null) : null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.
    
    - equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다.
    - 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
    - equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.
    
    - 양질의 equals 메서드 구현 방법을 단계별로 정리해보겠다.
      >1. == 연산자를 사용해 입력이 자기 자신이 참조인지 확인한다.
      >2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
      >3. 입력을 올바른 타입으로 형변환한다.
      >4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모드 일치하는지 하나씩 검사한다.
    
    - equals를 다 구현했다면 세 가지만 자문해보자. 대칭적인가? 추이성이 있는가? 일관적인가?
  
  - ### 아이템 11. equals를 재정의하려거든 hashCode도 재정의하라
    - equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.
    - 다음은 Object 명세에서 발췌한 규약이다.
      >- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
      >- equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
      >- equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환애야 해시테이블의 성능이 좋아진다.
    
    - hash 재정의를 잘못했을 때 크게 문제가 되는 조항은 두 번째다.
    - hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다.

  - ### 아이템 12. toString을 항상 재정의하라
    - toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
    - 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.
    - 포맷을 명시하든 아니든 여러분의 의도는 명확히 밝혀야 한다.
    - toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.

  - ### 아이템 13. clone 재정의는 주의해서 진행하라
    - 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.
    - clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.
    - Cloneable 아키텍처는 '가변 객체를 참조하는 필드는 final로 선언하라'는 일반 용법과 충돌한다.
    - public인 clone 메서드에서는 throw절을 없애야 한다.
    - Cloneable/clone 방식보다 복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있다.

  - ### 아이템 14. Comparable을 구현할지 고려하라
    - compareTo 메서드의 일반 규약은 equals의 규약과 비슷하다.
      >- 이 객체와 주어진 객체의 순서를 비교한다.
      >- 이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환한다.
      >- 이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.
      >- 다음 설명에서 sgn(표현식) 표기는 수학에서 말하는 부호 함수(signum function)를 뜻하며, 표현식의 값이 음수, 0, 양수일 때 -1, 0, 1을 반환하도록 정의했다.
      >---
      >- Comparable을 구현한 클래스는 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))여야 한다. (따라서 x.compareTo(y)는 y.compareTo(x)가 예외를 던질때에 한해 예외를 던져야 한다)
      >- Comparable을 구현한 클래스는 추이성을 보장해야 한다. 즉, (x.compareTo(y) > 0 && y.compareTo(z) > 0)이면 x.compareTo(z) > 0이다.
      >- Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))다.
      >- 이번 권고가 필수는 아니지만 꼭 지키는 게 좋다. (x.compareTo(y) == 0) == (x.equals(y))여야 한다.
      >- Comparable을 구현하고 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다. 다음과 같이 명시하면 적당할 것이다.
      >- "주의 : 이 클래스의 순서는 equals 메서드와 일관되지 않다."
    
    - 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다.
    - compareTo 메서드에서 관계 연산자 <와 >를 사용하는 이전 방식을 거추장스럽고 오류를 유발하니, 이제는 추천하지 않는다.
    - 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.

## 클래스와 인터페이스
자바 언어에는 클래스와 인터페이스 설계에 사용하는 강력한 요소가 많이 있다. 이런 요소를 적절히 활용하여 클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만든 방법을 안내한다.

  - ### 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라
    - 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
    - public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
    - public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
    - 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.

  - ### 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
    - 패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공해야 한다.
    - package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 하등의 문제가 없다.

  - ### 아이템 17. 변경 가능성을 최소화하라
    - 클래스를 불변으로 만들려면 다음 다섯가지 규칙을 따르면 된다.
      >- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
      >- 클래스를 확장할 수 없도록 한다.
      >- 모든 필드를 final로 선언한다.
      >- 모든 필드를 private으로 선언한다.
      >- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    
    - 불변 객체는 단순하다.
    - 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.
    - 불변 객체는 안심하고 공유할 수 있다.
    - 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
    - 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
    - 불변 객체는 그 자체로 실패 원자성(예외가 발생해도 호출 전과 상태가 같다는 성질)을 제공한다.
    - 불변 클래스에도 단점은 있다. 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.
    - 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
    - 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
    - 다른 합단한 이유가 없다면 모든 필드는 private final이어야 한다.
    - 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

  - ### 아이템 18. 상속보다는 컴포지션을 사용하라
    - 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
    - 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
    - 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다.

  - ### 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
    - 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
    - API 문서의 메서드 설명 끝에서 종종 "implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.
    - 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
    - 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다.
    - 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
    - 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
    - clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
    - 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다.
    - 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.

  - ### 아이템 20. 추상 클래스보다는 인터페이스를 우선하라
    - 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.
    - 인터페이스는 믹스인(mixin, 클래스가 구현할 수 있는 타입) 정의에 안성맞춤이다.
    - Comparable은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스다.
    - 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.
    - 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.
    - 단순 구현(simple implementation)은 골격 구현의 작은 변종이다.

  - ### 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라
    - 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.
    - 디폴트 메서드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.
    - 디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.
    - 인터페이스를 릴리스한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성을 기대서는 안 된다.

  - ### 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라
    - 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.
    - 상수 인터페이스는 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 말한다.
    - 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위다.

  - ### 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라
    - 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.
    - 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류일 뿐이다.

  - ### 아이템 24. 멤버 클래스는 되도록 static으로 만들라
    - 중첩 클래스에느 네 가지가 있으며, 각각의 쓰임이 다르다.
    - 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만든다.
    - 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로, 그렇지 않으면 정적(static)으로 만들자.
    - 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 
    - 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 만들고, 그렇지 않다면 지역 클래스로 만들자.